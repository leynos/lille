import types
import entity_state
import constants
import geometry

// --- Entity Position Relations ---
// `Force` captures all momentary forces acting on an entity during the
// current tick. The host application should replace this relation each frame.
input relation Force(entity: EntityID, fx: GCoord, fy: GCoord, fz: GCoord)
output relation NewPosition(entity: EntityID, x: GCoord, y: GCoord, z: GCoord)
output relation NewVelocity(entity: EntityID, nvx: GCoord, nvy: GCoord, nvz: GCoord)
// --- Dynamics ---
relation AppliedAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
AppliedAcceleration(e, fx / mass, fy / mass, fz / mass) :-
    Force(e, fx, fy, fz),
    (Mass(e, mass) or var mass = default_mass()),
    mass > 0.0.

relation GravitationalAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
GravitationalAcceleration(e, 0.0, 0.0, gravity_pull()) :- IsUnsupported(e).

relation FrictionalDeceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
FrictionalDeceleration(e, fdx, fdy, 0.0) :-
    IsStanding(e),
    var coeff = ground_friction(),
    Velocity(e, vx, vy, _),
    var h_mag = vec_mag(vx, vy, 0.0), h_mag > 0.0,
    var nvec = vec_normalize(vx, vy, 0.0),
    var nx = nvec.0,
    var ny = nvec.1,
    var decel_mag = min(h_mag, coeff),
    fdx = -nx * decel_mag, fdy = -ny * decel_mag.
FrictionalDeceleration(e, fdx, fdy, 0.0) :-
    IsUnsupported(e),
    var coeff = air_friction(),
    Velocity(e, vx, vy, _),
    var h_mag = vec_mag(vx, vy, 0.0), h_mag > 0.0,
    var nvec2 = vec_normalize(vx, vy, 0.0),
    var nx = nvec2.0,
    var ny = nvec2.1,
    var decel_mag = min(h_mag, coeff),
    fdx = -nx * decel_mag, fdy = -ny * decel_mag.

relation NetAccelRow(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
NetAccelRow(e, ax, ay, az) :- AppliedAcceleration(e, ax, ay, az).
NetAccelRow(e, ax, ay, az) :- GravitationalAcceleration(e, ax, ay, az).
NetAccelRow(e, ax, ay, az) :- FrictionalDeceleration(e, ax, ay, az).

relation SumAx(e: EntityID, ax: GCoord)
SumAx(e, sum(ax_i)) :- NetAccelRow(e, ax_i, _, _).

relation SumAy(e: EntityID, ay: GCoord)
SumAy(e, sum(ay_i)) :- NetAccelRow(e, _, ay_i, _).

relation SumAz(e: EntityID, az: GCoord)
SumAz(e, sum(az_i)) :- NetAccelRow(e, _, _, az_i).

relation NetAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
NetAcceleration(e, ax, ay, az) :-
    SumAx(e, ax),
    SumAy(e, ay),
    SumAz(e, az).

relation UnclampedNewVelocity(e: EntityID, vx: GCoord, vy: GCoord, vz: GCoord)
UnclampedNewVelocity(e, vx + ax * delta_time(), vy + ay * delta_time(), vz + az * delta_time()) :-
    Velocity(e, vx, vy, vz),
    NetAcceleration(e, ax, ay, az).

NewVelocity(e, nvx, nvy, final_nvz) :-
    IsUnsupported(e),
    UnclampedNewVelocity(e, nvx, nvy, raw_nvz),
    var clamped = max(min(raw_nvz, terminal_velocity()), -terminal_velocity()),
    var final_nvz = clamped.

NewVelocity(e, nvx, nvy, 0.0) :-
    IsStanding(e),
    UnclampedNewVelocity(e, nvx, nvy, _).

// Placeholder rule mirroring input to output
NewPosition(e, x, y, z) :- Position(e, x, y, z).
