import types
import entity_state
import constants
import geometry
import fp
import souffle_lib

function sum_group(g: Group<EntityID, GCoord>): GCoord {
    var acc = 0.0;
    for ((val, w) in g) {
        acc = acc + val * (w as GCoord);
    };
    acc
}

extern function vec_mag(x: GCoord, y: GCoord, z: GCoord): GCoord
extern function vec_normalize(x: GCoord, y: GCoord, z: GCoord): (GCoord, GCoord, GCoord)

// --- Entity Position Relations ---
// `Force` captures all momentary forces acting on an entity during the
// current tick. The host application should replace this relation each frame.
input relation Force(entity: EntityID, fx: GCoord, fy: GCoord, fz: GCoord)
output relation NewPosition(entity: EntityID, x: GCoord, y: GCoord, z: GCoord)
output relation NewVelocity(entity: EntityID, nvx: GCoord, nvy: GCoord, nvz: GCoord)
// --- Dynamics ---
relation AppliedAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
AppliedAcceleration(e, fx / mass, fy / mass, fz / mass) :-
    Force(e, fx, fy, fz),
    Mass(e, mass),
    mass > 0.0.
AppliedAcceleration(e, fx / mass, fy / mass, fz / mass) :-
    Force(e, fx, fy, fz),
    not Mass(e, _),
    var mass = default_mass(),
    mass > 0.0.

relation GravitationalAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
GravitationalAcceleration(e, 0.0, 0.0, gravity_pull()) :- IsUnsupported(e).

relation FrictionalDeceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
FrictionalDeceleration(e, fdx, fdy, 0.0) :-
    IsStanding(e),
    var coeff = ground_friction(),
    Velocity(e, vx, vy, _),
    var h_mag = vec_mag(vx, vy, 0.0), h_mag > 0.0,
    var nvec = vec_normalize(vx, vy, 0.0),
    var nx = nvec.0,
    var ny = nvec.1,
    var decel_mag = min(h_mag, coeff),
    var fdx = -nx * decel_mag, var fdy = -ny * decel_mag.
FrictionalDeceleration(e, fdx, fdy, 0.0) :-
    IsUnsupported(e),
    var coeff = air_friction(),
    Velocity(e, vx, vy, _),
    var h_mag = vec_mag(vx, vy, 0.0), h_mag > 0.0,
    var nvec2 = vec_normalize(vx, vy, 0.0),
    var nx = nvec2.0,
    var ny = nvec2.1,
    var decel_mag = min(h_mag, coeff),
    var fdx = -nx * decel_mag, var fdy = -ny * decel_mag.

relation NetAccelRow(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
NetAccelRow(e, ax, ay, az) :- AppliedAcceleration(e, ax, ay, az).
NetAccelRow(e, ax, ay, az) :- GravitationalAcceleration(e, ax, ay, az).
NetAccelRow(e, ax, ay, az) :- FrictionalDeceleration(e, ax, ay, az).

relation SumAx(e: EntityID, ax: GCoord)
SumAx(e, ax) :-
    NetAccelRow(e, ax_i, _, _),
    var group = ax_i.group_by(e),
    var ax = sum_group(group).

relation SumAy(e: EntityID, ay: GCoord)
SumAy(e, ay) :-
    NetAccelRow(e, _, ay_i, _),
    var group = ay_i.group_by(e),
    var ay = sum_group(group).

relation SumAz(e: EntityID, az: GCoord)
SumAz(e, az) :-
    NetAccelRow(e, _, _, az_i),
    var group = az_i.group_by(e),
    var az = sum_group(group).

relation NetAcceleration(e: EntityID, ax: GCoord, ay: GCoord, az: GCoord)
NetAcceleration(e, ax, ay, az) :-
    SumAx(e, ax),
    SumAy(e, ay),
    SumAz(e, az).

relation UnclampedNewVelocity(e: EntityID, vx: GCoord, vy: GCoord, vz: GCoord)
UnclampedNewVelocity(e, vx + ax * delta_time(), vy + ay * delta_time(), vz + az * delta_time()) :-
    Velocity(e, vx, vy, vz),
    NetAcceleration(e, ax, ay, az).

NewVelocity(e, nvx, nvy, final_nvz) :-
    IsUnsupported(e),
    UnclampedNewVelocity(e, nvx, nvy, raw_nvz),
    var clamped = max(min(raw_nvz, terminal_velocity()), -terminal_velocity()),
    var final_nvz = clamped.

NewVelocity(e, nvx, nvy, 0.0) :-
    IsStanding(e),
    UnclampedNewVelocity(e, nvx, nvy, _).

// Placeholder rule mirroring input to output
NewPosition(e, x, y, z) :- Position(e, x, y, z).
